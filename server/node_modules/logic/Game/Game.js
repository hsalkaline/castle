var _ = require('underscore'),
    util = require('util'),
    EventEmitter = require('service/EventEmitter/EventEmitter'),
    GameParticipants = require('logic/GameParticipants/GameParticipants'),
    ResourceBag = require('logic/Resources/ResourceBag/ResourceBag'),
    Treasury = require('logic/Treasury/Treasury'),
    Round = require('logic/Round/Round.js'),
    Q = require('q');

var playersToRounds = {
        2: 12,
        3: 15,
        4: 12
    },
    PHASE = [
        'PLAYERS_GATHERING',
        'ROUND_BEGIN',
        'CARDS_SELECTION',
        'CARDS_DISPATCH'
    ].reduce(function(acc, next) {
        acc[next] = next;
        return acc;
    }, {});

var Resource

var Field = function() {
    this.field = {
        traders: ['sand', 'wood', ''].map(function(resourceId) {
            return {
                resource: resourceId,
                player: null
            };
        })
    };
};


var Game = function(config) {
    var _this = this;

    config = config || {};
    this.maxPlayers = config.maxPlayers || 2;
    this.participants = new GameParticipants({maxPlaces: this.maxPlayers});

    this.participants
        .once('participants.filled', function() {
            _this.start();
        })
        .on('participants.full', function() {
            console.error('no more room!');
        });

    this.phase = PHASE.PLAYERS_GATHERING;
    this.treasury = new Treasury();
    this.roundMoney = new ResourceBag();

    console.assert(this.maxPlayers <= 4 && this.maxPlayers >= 2);
};

util.inherits(Game, EventEmitter);

_(Game.prototype).extend({
    onSetPhase: {
        'CARDS_SELECTION': function() {
            this.round = new Round({
                roundNumber: this.totalRounds - this.roundsRemains--,
                participants: this.participants
            });

            var activePlayer = this.getActivePlayer();
            this.roundMoney.transfer(activePlayer.player.resources, {money: 1});

            this._setPhase(PHASE.CARDS_DISPATCH);
        },
        'CARDS_DISPATCH': function() {
            if (this.roundsRemains === 0/* || everyBuildingHasBeenBuilt*/) {
                //@todo: scores
                //@todo unbind
                return;
            }

            this._playNextCardPhase();
        }
    },

    _playNextCardPhase: function() {
        var cards = this.round.nextCardSet(),
            game = this;

        if (cards) {
            var promise = Q(),
                onCard = function(card) {
                    var deferred = Q.defer();
                    card.once('done', deferred.resolve.bind(deferred));
                    card.play();
                    return deferred.promise;
                };

            cards.forEach(function (card) {
                promise = promise.then(onCard.bind(null, card));
            });

            promise.done(function() {
                cards.forEach(function(card) {
                    card.onPhaseComplete(game);
                });
                this._playNextCardPhase();
            }.bind(this));
        } else {
            this._setPhase(PHASE.CARDS_SELECTION);
        }
    },

    getActivePlayer: function() {
        return this.participants.playersSequence(this.round.getRoundNumber())[0];
    },

    _setPhase: function(phase) {
        this.phase = phase;
        this.onSetPhase[phase].call(this);
        this.emit('phase.changed', this.phase);
    },

    start: function() {
        this.totalRounds = this.roundsRemains = playersToRounds[this.participants.length()];

        this.treasury.transfer(this.roundMoney, {money: this.totalRounds});
        this._setPhase(PHASE.CARDS_SELECTION);
    },

    join: function(player) {
        if (this.phase !== PHASE.PLAYERS_GATHERING) {
            this.emit('game.error', {message: 'game already started'});
            return;
        }
        this.participants.join(player);
    },

    allowToPlaceTrader: function(player) {
        this.emit('trader.can_be_placed', {player: player});
        //todo: set timeout, listen to place.trader and remove timeout
    },

    silverTraderIsAllowed: function() {
        return true;
    }
});

module.exports = Game;
